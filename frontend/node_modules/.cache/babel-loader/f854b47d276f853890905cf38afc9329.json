{"ast":null,"code":"import { useEffect } from 'react';\nimport { useSubscriptionInternal } from './internal/use-subscription-internal';\nexport function useSubscription(input$, observerOrNext$, error, complete) {\n  return useSubscriptionInternal(useEffect, [input$, observerOrNext$, error, complete]);\n}","map":{"version":3,"mappings":"AACA,SAA2BA,SAA3B,QAA4C,OAA5C;AACA,SAASC,uBAAT,QAAwC,sCAAxC;AAsDA,OAAM,SAAUC,eAAV,CACJC,MADI,EAEJC,eAFI,EAOJC,KAPI,EAQJC,QARI,EAQsC;AAE1C,SAAOL,uBAAuB,CAACD,SAAD,EAAY,CACxCG,MADwC,EAExCC,eAFwC,EAGxCC,KAHwC,EAIxCC,QAJwC,CAAZ,CAA9B;AAMD","names":["useEffect","useSubscriptionInternal","useSubscription","input$","observerOrNext$","error","complete"],"sources":["F:\\SettleGuide\\frontend\\node_modules\\observable-hooks\\src\\use-subscription.ts"],"sourcesContent":["import { Observable, PartialObserver, Subscription } from 'rxjs'\nimport { MutableRefObject, useEffect } from 'react'\nimport { useSubscriptionInternal } from './internal/use-subscription-internal'\n\n/**\n * Accepts an Observable and optional `next`, `error`, `complete` functions.\n * These functions must be in correct order.\n * Use `undefined` or `null` for placeholder.\n *\n * Subscription will unsubscribe when unmount, you can also\n * unsubscribe manually.\n *\n * ⚠ **Note:** To make it concurrent mode compatible, the subscription happens\n * after the render is committed to the screen\n * which means even the Observable emits synchronous values\n * they will arrive after the first rendering.\n *\n * Note that changes of callbacks will not trigger\n * an emission. If you need that just create another\n * Observable of the callback with [[useObservable]].\n *\n * (From v2.0) You can access closure directly inside callback like in `useEffect`.\n * `useSubscription` will ensure the latest callback is called.\n *\n * (From v2.3.4) when the Observable changes `useSubscription` will automatically\n * unsubscribe the old one and resubscribe to the new one.\n *\n * ⚠ **Note:** Due to the design of RxJS, once an error occurs in an observable, the observable\n * is killed.\n * You should prevent errors from reaching observables or `catchError` in sub-observables.\n * You can also make the observable as state and replace it on error.\n * `useSubscription` will automatically switch to the new one.\n *\n * @template TInput Input value within Observable.\n *\n * @param input$ Input Observable.\n * @param observer Observer\n */\nexport function useSubscription<TInput>(\n  input$: Observable<TInput>,\n  observer?: PartialObserver<TInput>\n): MutableRefObject<Subscription | undefined>\n/**\n * @template TInput Input value within Observable.\n *\n * @param input$ Input Observable.\n * @param next Notify when a new value is emitted.\n * @param error Notify when a new error is thrown.\n * @param complete Notify when the Observable is complete.\n */\nexport function useSubscription<TInput>(\n  input$: Observable<TInput>,\n  next?: ((value: TInput) => void) | null | undefined,\n  error?: ((error: any) => void) | null | undefined,\n  complete?: (() => void) | null | undefined\n): MutableRefObject<Subscription | undefined>\nexport function useSubscription<TInput>(\n  input$: Observable<TInput>,\n  observerOrNext$?:\n    | PartialObserver<TInput>\n    | ((value: TInput) => void)\n    | null\n    | undefined,\n  error?: ((error: any) => void) | null | undefined,\n  complete?: (() => void) | null | undefined\n): MutableRefObject<Subscription | undefined> {\n  return useSubscriptionInternal(useEffect, [\n    input$,\n    observerOrNext$,\n    error,\n    complete\n  ])\n}\n"]},"metadata":{},"sourceType":"module"}