{"ast":null,"code":"import { useIsomorphicLayoutEffect } from '../helpers';\nimport { useRef } from 'react';\n/**\n *\n * @template TInput Input value within Observable.\n *\n * @param useCustomEffect useEffect or useLayoutEffect\n * @param args collected arguments\n */\n\nexport function useSubscriptionInternal(useCustomEffect, args) {\n  var argsRef = useRef(args);\n  var subscriptionRef = useRef(); // Update the latest observable and callbacks\n  // synchronously after render being committed\n\n  useIsomorphicLayoutEffect(function () {\n    argsRef.current = args;\n  });\n  useCustomEffect(function () {\n    // keep in closure for checking staleness\n    var input$ = argsRef.current[0];\n    var subscription = input$.subscribe({\n      next: function (value) {\n        var _a;\n\n        if (input$ !== argsRef.current[0]) {\n          // stale observable\n          return;\n        }\n\n        var nextObserver = ((_a = argsRef.current[1]) === null || _a === void 0 ? void 0 : _a.next) || argsRef.current[1];\n\n        if (nextObserver) {\n          return nextObserver(value);\n        }\n      },\n      error: function (error) {\n        var _a;\n\n        if (input$ !== argsRef.current[0]) {\n          // stale observable\n          return;\n        }\n\n        var errorObserver = ((_a = argsRef.current[1]) === null || _a === void 0 ? void 0 : _a.error) || argsRef.current[2];\n\n        if (errorObserver) {\n          return errorObserver(error);\n        }\n\n        console.error(error);\n      },\n      complete: function () {\n        var _a;\n\n        if (input$ !== argsRef.current[0]) {\n          // stale observable\n          return;\n        }\n\n        var completeObserver = ((_a = argsRef.current[1]) === null || _a === void 0 ? void 0 : _a.complete) || argsRef.current[3];\n\n        if (completeObserver) {\n          return completeObserver();\n        }\n      }\n    });\n    subscriptionRef.current = subscription;\n    return function () {\n      subscription.unsubscribe();\n    };\n  }, [args[0]]);\n  return subscriptionRef;\n}","map":{"version":3,"mappings":"AACA,SAASA,yBAAT,QAA0C,YAA1C;AACA,SAAsCC,MAAtC,QAAoD,OAApD;AASA;;;;;;;;AAOA,OAAM,SAAUC,uBAAV,CACJC,eADI,EAEJC,IAFI,EAEc;AAElB,MAAMC,OAAO,GAAGJ,MAAM,CAACG,IAAD,CAAtB;AACA,MAAME,eAAe,GAAGL,MAAM,EAA9B,CAHkB,CAKlB;AACA;;AACAD,2BAAyB,CAAC;AACxBK,WAAO,CAACE,OAAR,GAAkBH,IAAlB;AACD,GAFwB,CAAzB;AAIAD,iBAAe,CAAC;AACd;AACA,QAAMK,MAAM,GAAGH,OAAO,CAACE,OAAR,CAAgB,CAAhB,CAAf;AAEA,QAAME,YAAY,GAAGD,MAAM,CAACE,SAAP,CAAiB;AACpCC,UAAI,EAAE,iBAAK;;;AACT,YAAIH,MAAM,KAAKH,OAAO,CAACE,OAAR,CAAgB,CAAhB,CAAf,EAAmC;AACjC;AACA;AACD;;AACD,YAAMK,YAAY,GAChB,OAACP,OAAO,CAACE,OAAR,CAAgB,CAAhB,CAAD,MAA+C,IAA/C,IAA+CM,aAA/C,GAA+C,MAA/C,GAA+CA,GAAEF,IAAjD,KACCN,OAAO,CAACE,OAAR,CAAgB,CAAhB,CAFH;;AAGA,YAAIK,YAAJ,EAAkB;AAChB,iBAAOA,YAAY,CAACE,KAAD,CAAnB;AACD;AACF,OAZmC;AAapCC,WAAK,EAAE,iBAAK;;;AACV,YAAIP,MAAM,KAAKH,OAAO,CAACE,OAAR,CAAgB,CAAhB,CAAf,EAAmC;AACjC;AACA;AACD;;AACD,YAAMS,aAAa,GACjB,OAACX,OAAO,CAACE,OAAR,CAAgB,CAAhB,CAAD,MAA+C,IAA/C,IAA+CM,aAA/C,GAA+C,MAA/C,GAA+CA,GAAEE,KAAjD,KACAV,OAAO,CAACE,OAAR,CAAgB,CAAhB,CAFF;;AAGA,YAAIS,aAAJ,EAAmB;AACjB,iBAAOA,aAAa,CAACD,KAAD,CAApB;AACD;;AACDE,eAAO,CAACF,KAAR,CAAcA,KAAd;AACD,OAzBmC;AA0BpCG,cAAQ,EAAE;;;AACR,YAAIV,MAAM,KAAKH,OAAO,CAACE,OAAR,CAAgB,CAAhB,CAAf,EAAmC;AACjC;AACA;AACD;;AACD,YAAMY,gBAAgB,GACpB,OAACd,OAAO,CAACE,OAAR,CAAgB,CAAhB,CAAD,MAA+C,IAA/C,IAA+CM,aAA/C,GAA+C,MAA/C,GAA+CA,GAAEK,QAAjD,KACAb,OAAO,CAACE,OAAR,CAAgB,CAAhB,CAFF;;AAGA,YAAIY,gBAAJ,EAAsB;AACpB,iBAAOA,gBAAgB,EAAvB;AACD;AACF;AArCmC,KAAjB,CAArB;AAwCAb,mBAAe,CAACC,OAAhB,GAA0BE,YAA1B;AAEA,WAAO;AACLA,kBAAY,CAACW,WAAb;AACD,KAFD;AAGD,GAjDc,EAiDZ,CAAChB,IAAI,CAAC,CAAD,CAAL,CAjDY,CAAf;AAmDA,SAAOE,eAAP;AACD","names":["useIsomorphicLayoutEffect","useRef","useSubscriptionInternal","useCustomEffect","args","argsRef","subscriptionRef","current","input$","subscription","subscribe","next","nextObserver","_a","value","error","errorObserver","console","complete","completeObserver","unsubscribe"],"sources":["F:\\SettleGuide\\frontend\\node_modules\\observable-hooks\\src\\internal\\use-subscription-internal.ts"],"sourcesContent":["import { Observable, PartialObserver, Subscription } from 'rxjs'\nimport { useIsomorphicLayoutEffect } from '../helpers'\nimport { MutableRefObject, useEffect, useRef } from 'react'\n\ntype Args<TInput> = [\n  Observable<TInput>, // inputs$\n  PartialObserver<TInput> | ((value: TInput) => void) | null | undefined,\n  ((error: any) => void) | null | undefined,\n  (() => void) | null | undefined\n]\n\n/**\n *\n * @template TInput Input value within Observable.\n *\n * @param useCustomEffect useEffect or useLayoutEffect\n * @param args collected arguments\n */\nexport function useSubscriptionInternal<TInput>(\n  useCustomEffect: typeof useEffect,\n  args: Args<TInput>\n): MutableRefObject<Subscription | undefined> {\n  const argsRef = useRef(args)\n  const subscriptionRef = useRef<Subscription>()\n\n  // Update the latest observable and callbacks\n  // synchronously after render being committed\n  useIsomorphicLayoutEffect(() => {\n    argsRef.current = args\n  })\n\n  useCustomEffect(() => {\n    // keep in closure for checking staleness\n    const input$ = argsRef.current[0]\n\n    const subscription = input$.subscribe({\n      next: value => {\n        if (input$ !== argsRef.current[0]) {\n          // stale observable\n          return\n        }\n        const nextObserver =\n          (argsRef.current[1] as PartialObserver<TInput>)?.next ||\n          (argsRef.current[1] as ((value: TInput) => void) | null | undefined)\n        if (nextObserver) {\n          return nextObserver(value)\n        }\n      },\n      error: error => {\n        if (input$ !== argsRef.current[0]) {\n          // stale observable\n          return\n        }\n        const errorObserver =\n          (argsRef.current[1] as PartialObserver<TInput>)?.error ||\n          argsRef.current[2]\n        if (errorObserver) {\n          return errorObserver(error)\n        }\n        console.error(error)\n      },\n      complete: () => {\n        if (input$ !== argsRef.current[0]) {\n          // stale observable\n          return\n        }\n        const completeObserver =\n          (argsRef.current[1] as PartialObserver<TInput>)?.complete ||\n          argsRef.current[3]\n        if (completeObserver) {\n          return completeObserver()\n        }\n      }\n    })\n\n    subscriptionRef.current = subscription\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [args[0]])\n\n  return subscriptionRef\n}\n"]},"metadata":{},"sourceType":"module"}