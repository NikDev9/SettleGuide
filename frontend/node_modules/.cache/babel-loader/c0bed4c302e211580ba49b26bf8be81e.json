{"ast":null,"code":"import { useState, useDebugValue, useEffect, useRef } from 'react';\nimport { useForceUpdate, useIsomorphicLayoutEffect } from './helpers';\n/**\n * Optimized for safely getting synchronous values from hot or pure observables\n * without triggering extra initial re-rendering.\n *\n * ⚠ If the observable is cold and with side effects\n * they will be performed at least twice!\n *\n * By default this hook will subscribe to the observable at least twice.\n * The first time is for getting synchronous value to prevent extra initial re-rendering.\n * In concurrent mode this may happen more than one time.\n *\n * @template TState State.\n *\n * @param state$ An observable of state value.\n */\n\nexport function useObservableEagerState(state$) {\n  var forceUpdate = useForceUpdate();\n  var state$Ref = useRef(state$);\n  var errorRef = useRef();\n  var isAsyncEmissionRef = useRef(false);\n  var didSyncEmit = useRef(false);\n\n  var _a = useState(function () {\n    var state;\n    state$.subscribe({\n      next: function (value) {\n        didSyncEmit.current = true;\n        state = value;\n      },\n      error: function (error) {\n        errorRef.current = error;\n      }\n    }).unsubscribe();\n    return state;\n  }),\n      state = _a[0],\n      setState = _a[1]; // update the latest observable\n  // synchronously after render being committed\n\n\n  useIsomorphicLayoutEffect(function () {\n    state$Ref.current = state$;\n  });\n  useEffect(function () {\n    errorRef.current = null; // keep in closure for checking staleness\n\n    var input$ = state$Ref.current;\n    var secondInitialValue = state;\n    var subscription = input$.subscribe({\n      next: function (value) {\n        if (input$ !== state$Ref.current) {\n          // stale observable\n          return;\n        }\n\n        if (isAsyncEmissionRef.current) {\n          // ignore synchronous value\n          // prevent initial re-rendering\n          setState(value);\n        } else {\n          secondInitialValue = value;\n        }\n      },\n      error: function (error) {\n        if (input$ !== state$Ref.current) {\n          // stale observable\n          return;\n        }\n\n        errorRef.current = error;\n        forceUpdate();\n      }\n    });\n\n    if (!isAsyncEmissionRef.current) {\n      // fix #86 where sync emission may happen before useEffect\n      if (secondInitialValue !== state) {\n        setState(secondInitialValue);\n      }\n    }\n\n    isAsyncEmissionRef.current = true;\n    return function () {\n      subscription.unsubscribe();\n    };\n  }, [state$]);\n\n  if (errorRef.current) {\n    // Let error boundary catch the error\n    throw errorRef.current;\n  }\n\n  if (didSyncEmit.current) {\n    useDebugValue(state);\n    return state;\n  } else {\n    throw new Error('Observable did not synchronously emit a value.');\n  }\n}","map":{"version":3,"mappings":"AAAA,SAASA,QAAT,EAAmBC,aAAnB,EAAkCC,SAAlC,EAA6CC,MAA7C,QAA2D,OAA3D;AAEA,SAASC,cAAT,EAAyBC,yBAAzB,QAA0D,WAA1D;AAEA;;;;;;;;;;;;;;;;AAeA,OAAM,SAAUC,uBAAV,CACJC,MADI,EACsB;AAE1B,MAAMC,WAAW,GAAGJ,cAAc,EAAlC;AAEA,MAAMK,SAAS,GAAGN,MAAM,CAACI,MAAD,CAAxB;AACA,MAAMG,QAAQ,GAAGP,MAAM,EAAvB;AACA,MAAMQ,kBAAkB,GAAGR,MAAM,CAAC,KAAD,CAAjC;AAEA,MAAMS,WAAW,GAAGT,MAAM,CAAC,KAAD,CAA1B;;AAEM,WAAoBH,QAAQ,CAAS;AACzC,QAAIa,KAAJ;AACAN,UAAM,CACHO,SADH,CACa;AACTC,UAAI,EAAE,iBAAK;AACTH,mBAAW,CAACI,OAAZ,GAAsB,IAAtB;AACAH,aAAK,GAAGI,KAAR;AACD,OAJQ;AAKTC,WAAK,EAAE,iBAAK;AACVR,gBAAQ,CAACM,OAAT,GAAmBE,KAAnB;AACD;AAPQ,KADb,EAUGC,WAVH;AAWA,WAAON,KAAP;AACD,GAdiC,CAA5B;AAAA,MAACA,KAAK,QAAN;AAAA,MAAQO,QAAQ,QAAhB,CAVoB,CA0B1B;AACA;;;AACAf,2BAAyB,CAAC;AACxBI,aAAS,CAACO,OAAV,GAAoBT,MAApB;AACD,GAFwB,CAAzB;AAIAL,WAAS,CAAC;AACRQ,YAAQ,CAACM,OAAT,GAAmB,IAAnB,CADQ,CAGR;;AACA,QAAMK,MAAM,GAAGZ,SAAS,CAACO,OAAzB;AAEA,QAAIM,kBAAkB,GAAGT,KAAzB;AAEA,QAAMU,YAAY,GAAGF,MAAM,CAACP,SAAP,CAAiB;AACpCC,UAAI,EAAE,iBAAK;AACT,YAAIM,MAAM,KAAKZ,SAAS,CAACO,OAAzB,EAAkC;AAChC;AACA;AACD;;AACD,YAAIL,kBAAkB,CAACK,OAAvB,EAAgC;AAC9B;AACA;AACAI,kBAAQ,CAACH,KAAD,CAAR;AACD,SAJD,MAIO;AACLK,4BAAkB,GAAGL,KAArB;AACD;AACF,OAbmC;AAcpCC,WAAK,EAAE,iBAAK;AACV,YAAIG,MAAM,KAAKZ,SAAS,CAACO,OAAzB,EAAkC;AAChC;AACA;AACD;;AACDN,gBAAQ,CAACM,OAAT,GAAmBE,KAAnB;AACAV,mBAAW;AACZ;AArBmC,KAAjB,CAArB;;AAwBA,QAAI,CAACG,kBAAkB,CAACK,OAAxB,EAAiC;AAC/B;AACA,UAAIM,kBAAkB,KAAKT,KAA3B,EAAkC;AAChCO,gBAAQ,CAACE,kBAAD,CAAR;AACD;AACF;;AAEDX,sBAAkB,CAACK,OAAnB,GAA6B,IAA7B;AAEA,WAAO;AACLO,kBAAY,CAACJ,WAAb;AACD,KAFD;AAGD,GA5CQ,EA4CN,CAACZ,MAAD,CA5CM,CAAT;;AA8CA,MAAIG,QAAQ,CAACM,OAAb,EAAsB;AACpB;AACA,UAAMN,QAAQ,CAACM,OAAf;AACD;;AAED,MAAIJ,WAAW,CAACI,OAAhB,EAAyB;AACvBf,iBAAa,CAACY,KAAD,CAAb;AAEA,WAAOA,KAAP;AACD,GAJD,MAIO;AACL,UAAM,IAAIW,KAAJ,CAAU,gDAAV,CAAN;AACD;AACF","names":["useState","useDebugValue","useEffect","useRef","useForceUpdate","useIsomorphicLayoutEffect","useObservableEagerState","state$","forceUpdate","state$Ref","errorRef","isAsyncEmissionRef","didSyncEmit","state","subscribe","next","current","value","error","unsubscribe","setState","input$","secondInitialValue","subscription","Error"],"sources":["F:\\SettleGuide\\frontend\\node_modules\\observable-hooks\\src\\use-observable-eager-state.ts"],"sourcesContent":["import { useState, useDebugValue, useEffect, useRef } from 'react'\nimport { Observable } from 'rxjs'\nimport { useForceUpdate, useIsomorphicLayoutEffect } from './helpers'\n\n/**\n * Optimized for safely getting synchronous values from hot or pure observables\n * without triggering extra initial re-rendering.\n *\n * ⚠ If the observable is cold and with side effects\n * they will be performed at least twice!\n *\n * By default this hook will subscribe to the observable at least twice.\n * The first time is for getting synchronous value to prevent extra initial re-rendering.\n * In concurrent mode this may happen more than one time.\n *\n * @template TState State.\n *\n * @param state$ An observable of state value.\n */\nexport function useObservableEagerState<TState>(\n  state$: Observable<TState>\n): TState {\n  const forceUpdate = useForceUpdate()\n\n  const state$Ref = useRef(state$)\n  const errorRef = useRef<Error | null>()\n  const isAsyncEmissionRef = useRef(false)\n\n  const didSyncEmit = useRef(false)\n\n  const [state, setState] = useState<TState>(() => {\n    let state: TState\n    state$\n      .subscribe({\n        next: value => {\n          didSyncEmit.current = true\n          state = value\n        },\n        error: error => {\n          errorRef.current = error\n        }\n      })\n      .unsubscribe()\n    return state!\n  })\n\n  // update the latest observable\n  // synchronously after render being committed\n  useIsomorphicLayoutEffect(() => {\n    state$Ref.current = state$\n  })\n\n  useEffect(() => {\n    errorRef.current = null\n\n    // keep in closure for checking staleness\n    const input$ = state$Ref.current\n\n    let secondInitialValue = state\n\n    const subscription = input$.subscribe({\n      next: value => {\n        if (input$ !== state$Ref.current) {\n          // stale observable\n          return\n        }\n        if (isAsyncEmissionRef.current) {\n          // ignore synchronous value\n          // prevent initial re-rendering\n          setState(value)\n        } else {\n          secondInitialValue = value\n        }\n      },\n      error: error => {\n        if (input$ !== state$Ref.current) {\n          // stale observable\n          return\n        }\n        errorRef.current = error\n        forceUpdate()\n      }\n    })\n\n    if (!isAsyncEmissionRef.current) {\n      // fix #86 where sync emission may happen before useEffect\n      if (secondInitialValue !== state) {\n        setState(secondInitialValue)\n      }\n    }\n\n    isAsyncEmissionRef.current = true\n\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [state$])\n\n  if (errorRef.current) {\n    // Let error boundary catch the error\n    throw errorRef.current\n  }\n\n  if (didSyncEmit.current) {\n    useDebugValue(state)\n\n    return state\n  } else {\n    throw new Error('Observable did not synchronously emit a value.')\n  }\n}\n"]},"metadata":{},"sourceType":"module"}