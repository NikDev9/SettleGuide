{"ast":null,"code":"import { useRef } from 'react';\nimport { useRefFn, getEmptySubject } from './helpers';\nexport function useObservableCallback(init, selector) {\n  var events$Ref = useRefFn(getEmptySubject);\n  var outputs$Ref = useRefFn(function () {\n    return init(events$Ref.current);\n  });\n  var callbackRef = useRef(function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    events$Ref.current.next(selector ? selector(args) : args[0]);\n  });\n  return [callbackRef.current, outputs$Ref.current];\n}","map":{"version":3,"mappings":"AACA,SAASA,MAAT,QAAuB,OAAvB;AACA,SAASC,QAAT,EAAmBC,eAAnB,QAA0C,WAA1C;AAsCA,OAAM,SAAUC,qBAAV,CAKJC,IALI,EAMJC,QANI,EAMgC;AAEpC,MAAMC,UAAU,GAAGL,QAAQ,CAAkBC,eAAlB,CAA3B;AACA,MAAMK,WAAW,GAAGN,QAAQ,CAAC;AAAM,eAAI,CAACK,UAAU,CAACE,OAAZ,CAAJ;AAAwB,GAA/B,CAA5B;AACA,MAAMC,WAAW,GAAGT,MAAM,CAAC;AAAC;;SAAA,yCAAgB;AAAhBU;;;AAC1BJ,cAAU,CAACE,OAAX,CAAmBG,IAAnB,CAAwBN,QAAQ,GAAGA,QAAQ,CAACK,IAAD,CAAX,GAAoBA,IAAI,CAAC,CAAD,CAAxD;AACD,GAFyB,CAA1B;AAGA,SAAO,CAACD,WAAW,CAACD,OAAb,EAAsBD,WAAW,CAACC,OAAlC,CAAP;AACD","names":["useRef","useRefFn","getEmptySubject","useObservableCallback","init","selector","events$Ref","outputs$Ref","current","callbackRef","args","next"],"sources":["F:\\SettleGuide\\frontend\\node_modules\\observable-hooks\\src\\use-observable-callback.ts"],"sourcesContent":["import { Observable, Subject } from 'rxjs'\nimport { useRef } from 'react'\nimport { useRefFn, getEmptySubject } from './helpers'\n\n/**\n * Returns a callback function and an events Observable.\n *\n * Whenever the callback is called, the Observable will\n * emit the first argument of the callback.\n *\n * (From v2.1.0) Optionally accepts a selector function that transforms\n * a list of event arguments into a single value.\n *\n * If you want value instead of Observable\n * see example on [[useObservableState]].\n *\n * âš  **Note:** `useObservableCallback` will call `init` once and always return\n * the same Observable. It is not safe to access closure (except other Observables)\n * directly inside `init`. Use ref or [[useObservable]] with `withLatestFrom` instead.\n *\n * @template TOutput Output value within Observable.\n * @template TInput Selected values.\n * @template TParams A tuple of event callback parameters.\n *\n * @param init A pure function that, when applied to an Observable,\n * returns an Observable.\n * @param selector A function that transforms an array of event arguments\n * into a single value.\n */\nexport function useObservableCallback<TOutput, TInput = TOutput>(\n  init: (events$: Observable<TInput>) => Observable<TOutput>\n): [(args: TInput) => void, Observable<TOutput>]\nexport function useObservableCallback<\n  TOutput,\n  TInput = TOutput,\n  TParams extends Readonly<any[]> = [TInput]\n>(\n  init: (events$: Observable<TInput>) => Observable<TOutput>,\n  selector: (args: TParams) => TInput\n): [(...args: TParams) => void, Observable<TOutput>]\nexport function useObservableCallback<\n  TOutput,\n  TInput = TOutput,\n  TParams extends Readonly<any[]> = [TInput]\n>(\n  init: (events$: Observable<TInput>) => Observable<TOutput>,\n  selector?: (args: TParams) => TInput\n): [(...args: TParams) => void, Observable<TOutput>] {\n  const events$Ref = useRefFn<Subject<TInput>>(getEmptySubject)\n  const outputs$Ref = useRefFn(() => init(events$Ref.current))\n  const callbackRef = useRef((...args: TParams) => {\n    events$Ref.current.next(selector ? selector(args) : args[0])\n  })\n  return [callbackRef.current, outputs$Ref.current]\n}\n"]},"metadata":{},"sourceType":"module"}