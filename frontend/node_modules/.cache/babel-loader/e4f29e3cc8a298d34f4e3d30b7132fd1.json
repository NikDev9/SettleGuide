{"ast":null,"code":"import { useSubscription } from './use-subscription';\nimport { useObservableStateInternal } from './internal/use-observable-state-internal';\nexport function useObservableState(state$OrInit, initialState) {\n  return useObservableStateInternal(useSubscription, state$OrInit, initialState);\n}","map":{"version":3,"mappings":"AACA,SAASA,eAAT,QAAgC,oBAAhC;AACA,SAASC,0BAAT,QAA2C,0CAA3C;AA4FA,OAAM,SAAUC,kBAAV,CACJC,YADI,EAOJC,YAPI,EAOkC;AAEtC,SAAOH,0BAA0B,CAACD,eAAD,EAAkBG,YAAlB,EAAgCC,YAAhC,CAAjC;AACD","names":["useSubscription","useObservableStateInternal","useObservableState","state$OrInit","initialState"],"sources":["F:\\SettleGuide\\frontend\\node_modules\\observable-hooks\\src\\use-observable-state.ts"],"sourcesContent":["import { BehaviorSubject, Observable } from 'rxjs'\nimport { useSubscription } from './use-subscription'\nimport { useObservableStateInternal } from './internal/use-observable-state-internal'\n\n/**\n * A sugar hook for getting values from an Observable.\n *\n * It can be used in two ways:\n *\n * 1. Offer an Observable and an optional initial state.\n *    ```js\n *    const output = useObservableState(input$, initialState)\n *    ```\n * 2. Offer an epic-like function and an optional initial state.\n *    ```js\n *    const [output, onInput] = useObservableState(\n *      (input$, initialState) => input$.pipe(...),\n *      initialState\n *    )\n *    ```\n *\n * The optional `initialState` is internally passed to `useState(initialState)`.\n * This means it can be either a state value or a function that returns the state\n * which is for expensive initialization.\n *\n * The `initialState`(or its returned result) is also passed to the `init` function.\n * This is useful if you want to implement reduer pattern which requires an initial state.\n *\n * ⚠ **Note:** These two ways use different hooks, choose either one each time\n * and do not change to the other one during Component's life cycle.\n *\n * ⚠ **Note:** `useObservableState` will call the epic-like `init` function only once\n * and always return the same Observable.\n * It is not safe to access closure directly inside `init`.\n * Use [[useObservable]] with `withLatestFrom` instead.\n *\n * ⚠ **Note:** To make it concurrent mode compatible, the subscription happens\n * after the render is committed to the screen which means even the Observable emits synchronous values\n * they will arrive after the first rendering.\n *\n * @template TState Output state.\n *\n * @param input$ A BehaviorSubject.\n */\nexport function useObservableState<TState>(\n  input$: BehaviorSubject<TState>\n): TState\n/**\n * @template TState Output state.\n *\n * @param input$ An Observable.\n */\nexport function useObservableState<TState>(\n  input$: Observable<TState>\n): TState | undefined\n/**\n * @template TState Output state.\n *\n * @param input$ An Observable.\n * @param initialState Optional initial state.\n * Can be the state value or a function that returns the state.\n */\nexport function useObservableState<TState>(\n  input$: Observable<TState>,\n  initialState: TState | (() => TState)\n): TState\n/**\n * @template TState Output state.\n * @template TInput Input values.\n *\n * @param init A epic-like function that, when applied to an Observable\n * and the initial state value, returns an Observable.\n */\nexport function useObservableState<TState, TInput = TState>(\n  init: (input$: Observable<TInput>) => Observable<TState>\n): [TState | undefined, (input: TInput) => void]\n/**\n * Different input output types with initial state.\n *\n * @template TState Output state.\n * @template TInput Input values.\n *\n * @param init A epic-like function that, when applied to an Observable\n * and the initial state value, returns an Observable.\n * @param initialState Optional initial state.\n * Can be the state value or a function that returns the state.\n */\nexport function useObservableState<TState, TInput = TState>(\n  init: (\n    input$: Observable<TInput>,\n    initialState: TState\n  ) => Observable<TState>,\n  initialState: TState | (() => TState)\n): [TState, (input: TInput) => void]\nexport function useObservableState<TState, TInput = TState>(\n  state$OrInit:\n    | Observable<TState>\n    | ((\n        input$: Observable<TInput>,\n        initialState?: TState\n      ) => Observable<TState>),\n  initialState?: TState | (() => TState)\n): TState | undefined | [TState | undefined, (input: TInput) => void] {\n  return useObservableStateInternal(useSubscription, state$OrInit, initialState)\n}\n"]},"metadata":{},"sourceType":"module"}