{"ast":null,"code":"import { BehaviorSubject, Subject } from 'rxjs';\n/**\n * Rewires Observable to Relay-like Suspense resource.\n */\n\nvar ObservableResource =\n/** @class */\nfunction () {\n  /**\n   * @param input$ An Observable.\n   * @param isSuccess A function that determines if the value emitted from\n   * `input$` is of success state. If false a Suspense is triggered.\n   *  Default all true.\n   */\n  function ObservableResource(input$, isSuccess) {\n    var _this = this;\n    /**\n     * Unlike Promise, Observable is a multiple push mechanism.\n     * Only force update when Suspense needs to restart.\n     */\n\n\n    this.shouldUpdate$$ = new Subject();\n    this.handler = this.getHandler();\n    this.valueRef$$ = new BehaviorSubject(undefined);\n    this.error = null;\n\n    this.isSuccess = function (value) {\n      return true;\n    };\n\n    this._isDestroyed = false;\n    this._updateCount = 0;\n\n    this.handleNext = function (value) {\n      var _a;\n\n      _this.error = null;\n\n      if (_this.isSuccess(value)) {\n        if (((_a = _this.valueRef$$.value) === null || _a === void 0 ? void 0 : _a.current) !== value) {\n          _this.valueRef$$.next({\n            current: value\n          });\n        }\n\n        if (_this.handler) {\n          // This will also remove the initial\n          // suspender if sync values are emitted.\n          var resolve = _this.handler.resolve;\n          _this.handler = null;\n          resolve();\n        }\n      } else if (!_this.handler) {\n        // start a new Suspense\n        _this.handler = _this.getHandler();\n\n        _this.shouldUpdate$$.next(true);\n      }\n    };\n\n    this.handleError = function (error) {\n      _this.error = error;\n\n      if (_this.handler) {\n        var resolve = _this.handler.resolve;\n        _this.handler = null; // Errors thrown from the request is not catchable by error boundaries.\n        // Here we resolve the suspender and let this.read throw the error.\n\n        resolve();\n      } else {\n        _this.shouldUpdate$$.next(true);\n      }\n    };\n\n    this.handleComplete = function () {\n      if (_this.handler) {\n        _this.error = new Error('Suspender ended unexpectedly.');\n        var resolve = _this.handler.resolve;\n        _this.handler = null; // Errors thrown from the request is not catchable by error boundaries.\n        // Here we resolve the suspender and let this.read throw the error.\n\n        resolve();\n      }\n    };\n\n    if (isSuccess) {\n      this.isSuccess = isSuccess;\n    }\n\n    this.input$ = input$;\n    this.subscription = input$.subscribe({\n      next: this.handleNext,\n      error: this.handleError,\n      complete: this.handleComplete\n    });\n  }\n\n  Object.defineProperty(ObservableResource.prototype, \"isDestroyed\", {\n    get: function () {\n      return this._isDestroyed;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  ObservableResource.prototype.read = function () {\n    var _a;\n\n    if (this.error) {\n      throw this.error;\n    }\n\n    if (this.handler) {\n      throw this.handler.suspender;\n    }\n\n    return (_a = this.valueRef$$.value) === null || _a === void 0 ? void 0 : _a.current;\n  };\n\n  ObservableResource.prototype.reload = function (newInput$) {\n    if (this._isDestroyed) {\n      throw new Error('Cannot reload a destroyed Observable Resource');\n    }\n\n    if (newInput$) {\n      this.input$ = newInput$;\n    }\n\n    this.subscription.unsubscribe();\n    this.error = null;\n\n    if (this.handler) {\n      this.handler.resolve();\n      this.handler = this.getHandler();\n    }\n\n    this.subscription = this.input$.subscribe({\n      next: this.handleNext,\n      error: this.handleError,\n      complete: this.handleComplete\n    });\n  };\n\n  ObservableResource.prototype.destroy = function () {\n    this._isDestroyed = true;\n    this.subscription.unsubscribe();\n    this.shouldUpdate$$.complete();\n\n    if (this.handler) {\n      this.error = new Error('Resource has been destroyed.');\n      var resolve = this.handler.resolve;\n      this.handler = null;\n      resolve();\n    }\n  };\n\n  ObservableResource.prototype.getHandler = function () {\n    var handler = {};\n    handler.suspender = new Promise(function (resolve) {\n      handler.resolve = resolve;\n    });\n    return handler;\n  };\n\n  return ObservableResource;\n}();\n\nexport { ObservableResource };","map":{"version":3,"mappings":"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","names":["BehaviorSubject","Subject","input$","isSuccess","getHandler","undefined","value","_this","error","valueRef$$","_a","current","next","handler","resolve","shouldUpdate$$","Error","subscription","subscribe","handleNext","handleError","complete","handleComplete","Object","ObservableResource","_isDestroyed","suspender","newInput$","unsubscribe","Promise"],"sources":["F:\\SettleGuide\\frontend\\node_modules\\observable-hooks\\src\\observable-resource.ts"],"sourcesContent":["import { Observable, BehaviorSubject, Subject, Subscription } from 'rxjs'\n\ninterface Handler<T = any> {\n  suspender: Promise<T>\n  resolve: (value?: T) => void\n}\n\n/**\n * Rewires Observable to Relay-like Suspense resource.\n */\nexport class ObservableResource<TInput, TOutput extends TInput = TInput> {\n  /**\n   * Unlike Promise, Observable is a multiple push mechanism.\n   * Only force update when Suspense needs to restart.\n   */\n  readonly shouldUpdate$$ = new Subject<true>()\n\n  get isDestroyed(): boolean {\n    return this._isDestroyed\n  }\n\n  private handler: Handler | null = this.getHandler()\n\n  public valueRef$$ = new BehaviorSubject<{ current: TOutput } | undefined>(\n    undefined\n  )\n\n  private error: any = null\n\n  public input$: Observable<TInput>\n\n  private subscription: Subscription\n\n  private isSuccess = (value: TInput): value is TOutput => true\n\n  private _isDestroyed = false\n\n  private _updateCount = 0\n\n  /**\n   * @param input$ An Observable.\n   * @param isSuccess A function that determines if the value emitted from\n   * `input$` is of success state. If false a Suspense is triggered.\n   *  Default all true.\n   */\n  constructor(\n    input$: Observable<TInput>,\n    isSuccess?: TInput extends TOutput\n      ? (value: TInput) => boolean\n      : (value: TInput) => value is TOutput\n  ) {\n    if (isSuccess) {\n      this.isSuccess = isSuccess as (value: TInput) => value is TOutput\n    }\n\n    this.input$ = input$\n\n    this.subscription = input$.subscribe({\n      next: this.handleNext,\n      error: this.handleError,\n      complete: this.handleComplete\n    })\n  }\n\n  read(): TOutput {\n    if (this.error) {\n      throw this.error\n    }\n    if (this.handler) {\n      throw this.handler.suspender\n    }\n    return this.valueRef$$.value?.current!\n  }\n\n  reload(newInput$?: Observable<TInput>): void {\n    if (this._isDestroyed) {\n      throw new Error('Cannot reload a destroyed Observable Resource')\n    }\n\n    if (newInput$) {\n      this.input$ = newInput$\n    }\n\n    this.subscription.unsubscribe()\n\n    this.error = null\n\n    if (this.handler) {\n      this.handler.resolve()\n      this.handler = this.getHandler()\n    }\n\n    this.subscription = this.input$.subscribe({\n      next: this.handleNext,\n      error: this.handleError,\n      complete: this.handleComplete\n    })\n  }\n\n  destroy(): void {\n    this._isDestroyed = true\n    this.subscription.unsubscribe()\n    this.shouldUpdate$$.complete()\n    if (this.handler) {\n      this.error = new Error('Resource has been destroyed.')\n      const { resolve } = this.handler\n      this.handler = null\n      resolve()\n    }\n  }\n\n  private handleNext = (value: TInput): void => {\n    this.error = null\n    if (this.isSuccess(value)) {\n      if (this.valueRef$$.value?.current !== value) {\n        this.valueRef$$.next({ current: value })\n      }\n      if (this.handler) {\n        // This will also remove the initial\n        // suspender if sync values are emitted.\n        const { resolve } = this.handler\n        this.handler = null\n        resolve()\n      }\n    } else if (!this.handler) {\n      // start a new Suspense\n      this.handler = this.getHandler()\n      this.shouldUpdate$$.next(true)\n    }\n  }\n\n  private handleError = (error: any): void => {\n    this.error = error\n    if (this.handler) {\n      const { resolve } = this.handler\n      this.handler = null\n      // Errors thrown from the request is not catchable by error boundaries.\n      // Here we resolve the suspender and let this.read throw the error.\n      resolve()\n    } else {\n      this.shouldUpdate$$.next(true)\n    }\n  }\n\n  private handleComplete = (): void => {\n    if (this.handler) {\n      this.error = new Error('Suspender ended unexpectedly.')\n      const { resolve } = this.handler\n      this.handler = null\n      // Errors thrown from the request is not catchable by error boundaries.\n      // Here we resolve the suspender and let this.read throw the error.\n      resolve()\n    }\n  }\n\n  private getHandler(): Handler {\n    const handler: Partial<Handler> = {}\n    handler.suspender = new Promise(resolve => {\n      handler.resolve = resolve\n    })\n    return handler as Handler\n  }\n}\n"]},"metadata":{},"sourceType":"module"}